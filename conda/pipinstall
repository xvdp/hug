#!/usr/bin/env bash
#
# place in a folder in the path, e.g. ~/.local/bin
# replaces `pip install <pkg> -c $CONDA_PREFIX/constraints.txt` with `pipinstall <pkg>`
#
set -eu
die(){ printf '%s\n' "$*" >&2; exit 1; }


join_and_sanitize () {
    local parts=()
    for arg in "$@"; do
        [[ "$arg" == -* ]] && continue   # drop any dashâ€‘option
        # strip version specifiers
        arg="${arg%%[![:alnum:]._-]*}"
        # turn path separators into underscores
        arg="${arg//\//_}"
        arg="${arg//\\/ _}"
        parts+=("$arg")
    done
    IFS=_; printf '%s\n' "${parts[*]}" | sed -E 's/[^[:alnum:]_]+/_/g'
}

SNAP_BEFORE="/tmp/${1}_before.txt"
SNAP_AFTER="/tmp/${1}_after.txt"
CONSTRAINTS="${CONDA_PREFIX}/constraints.txt"

[ -n "${CONDA_PREFIX:-}" ] || die "CONDA_PREFIX is not set: to use outside of conda, modify constraint FOLDER ."
command -v mamba >/dev/null 2>&1 || die "mamba not found on PATH"

# --- block packages from being installed in base
if [[ ${CONDA_DEFAULT_ENV} == "base" ]]; then
    die "attempting to install package on (base) blocked"
fi

# --- decide whether we need to add -c ---------------------------------------
user_has_constraint=false
for arg in "$@"; do
  case "$arg" in
    -c|--constraint) user_has_constraint=true ;;      # covers "-c file"
    -c*)  user_has_constraint=true ;;                # covers "-cfile"
    --constraint=*) user_has_constraint=true ;;
  esac
done

pip_args=""
if [ "$user_has_constraint" = false ] && [ -f "$CONSTRAINTS" ]; then
  pip_args="-c $CONSTRAINTS"
fi

# --- snapshots and install ---------------------------------------------------
name=$(join_and_sanitize "$@")
datestamp=$(date '+%Y%m%d%H%M%S')

mamba list > "$SNAP_BEFORE"
python -m pip install $pip_args "$@"               # real pip call
mamba list > "$SNAP_AFTER"

# --- make temp files ---------------------------------------------------------
tmp_added=$(mktemp)     # lines that appear only in AFTER
tmp_removed=$(mktemp)   # lines that disappear in AFTER
tmp_updated=$(mktemp)   # lines that changed (same pkg name, different record)
grep -F -x -v -f "$SNAP_BEFORE" "$SNAP_AFTER" | grep -v '^#' >"$tmp_added" || true
grep -F -x -v -f "$SNAP_AFTER" "$SNAP_BEFORE" | grep -v '^#' >"$tmp_removed" || true
awk '
    FNR==NR && !/^#/ { a[$1]=$0; next }   # read BEFORE, index by first field (pkg name)
    !/^#/ && ($1 in a) && a[$1]!=$0 {   # line exists in AFTER, same name, different content
        print a[$1]"  -->  "$0
    }
' "$SNAP_BEFORE" "$SNAP_AFTER" >"$tmp_updated" || true
outfile="No_file"
# --- only include changes in final report -------------------------------------
if [[ -s "$tmp_added" || -s "$tmp_removed" || -s "$tmp_updated" ]]; then
    outfile="${CONDA_PREFIX}/install_${name}_${datestamp}.txt"
    {
        printf "===========\n%s\n" "$0"
        printf "python -m pip install %s %s\n" "$pip_args" "$*"
        # Only print a section when it actually has content
        if [[ -s "$tmp_added" ]]; then
            printf "\n(+) added\n"
            cat "$tmp_added"
        fi
        if [[ -s "$tmp_removed" ]]; then
            printf "\n(-) removed\n"
            cat "$tmp_removed"
        fi
        if [[ -s "$tmp_updated" ]]; then
            printf "\n(>) updated\n"
            cat "$tmp_updated"
        fi
    } >"$outfile"
fi

# rm -f "$SNAP_BEFORE" "$SNAP_AFTER"
if [ -f "$outfile" ]; then
    printf "Installed ${1}, saved updated lib list to ${outfile}\n"
    cat ${outfile}
else
    echo "All requirements satisfied, nothing installed"
fi
rm -f "$tmp_added" "$tmp_removed" "$tmp_updated"

